<?xml version="1.0" encoding="utf-8"?>
<Page xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <PageId>6dd50fff-50b6-4121-8179-f882ac62598f</PageId>
  <Text>{\rtf1\ansi\ansicpg949\deff0\deflang1033\deflangfe1042{\fonttbl{\f0\fnil\fcharset0 Microsoft Sans Serif;}{\f1\fmodern\fprq1\fcharset129 \'b1\'bc\'b8\'b2;}{\f2\fnil\fcharset129 \'b1\'bc\'b8\'b2;}{\f3\fnil\fcharset0 NanumGothicCoding;}{\f4\fnil NanumGothicCoding;}{\f5\fnil\fcharset129 NanumGothicCoding;}{\f6\fnil DotumChe;}{\f7\fnil\fcharset2 Symbol;}}
{\colortbl ;\red0\green0\blue255;\red255\green255\blue255;\red0\green0\blue0;\red43\green145\blue175;\red0\green128\blue0;\red163\green21\blue21;\red180\green180\blue180;\red30\green30\blue30;}
\viewkind4\uc1\pard{\pntext\f7\'B7\tab}{\*\pn\pnlvlblt\pnf7\pnindent0{\pntxtb\'B7}}\fi-300\li450\lang1042\f0\fs18 Set\fs20\par
\pard\fs18\tab - \f1\'bf\'ac\'b0\'fc \'c4\'c1\'c5\'d7\'c0\'cc\'b3\'ca\f0\fs20  \f1\fs18\'c0\'cc\'b8\'e7 '\'b3\'eb\'b5\'e5 \'b1\'e2\'b9\'dd \'c4\'c1\'c5\'d7\'c0\'cc\'b3\'ca' \'c0\'cc\'b4\'d9.\par
\tab - \'c2\'fc\'b0\'ed\'b7\'ce\f0\fs20  \f1\fs18\'b8\'f0\'b5\'e7 \'bf\'ac\'b0\'fc\'c4\'c1\'c5\'d7\'c0\'cc\'b3\'ca\'b4\'c2 \'b1\'d5\'c7\'fc 2\'c1\'f8 \'c6\'ae\'b8\'ae\'b7\'ce \'b1\'b8\'c7\'f6(\'b7\'b9\'b5\'e5-\'ba\'ed\'b7\'a2\'c6\'ae\'b8\'ae)\par
\tab - \'bf\'ac\'b0\'fc \'c4\'c1\'c5\'d7\'c0\'cc\'b3\'ca\'c1\'df \'b4\'dc\'bc\'f8\'c7\'d1 \'c4\'c1\'c5\'d7\'c0\'cc\'b3\'ca\'b7\'ce \f0 Key\f1\'b6\'f3 \'ba\'d2\'b8\'ae\'b4\'c2 \'bf\'f8\'bc\'d2(\f0 Value)\f2\'c0\'c7 \'c1\'fd\'c7\'d5\'c0\'b8\'b7\'ce \'c0\'cc\'b7\'e7\'be\'ee\'c1\'f8 \'c4\'c1\'c5\'d7\'c0\'cc\'b3\'ca\'c0\'cc\'b4\'d9.\par
\tab - \f0 Map\f2\'b0\'fa\'c0\'c7 \'c2\'f7\'c0\'cc\'c1\'a1\'c0\'ba \f0 Set\f2\'c0\'ba \'bf\'c0\'c1\'f7 \f0 Key\f2\'b8\'b8 \'c0\'fa\'c0\'e5\'c7\'cf\'b0\'ed \'c1\'a4\'b7\'c4\'c7\'d1\'b4\'d9\'b4\'c2 \'c1\'a1\par
\tab - \f0 Key\f2\'b0\'aa\'c0\'cc \'c1\'df\'ba\'b9\'c0\'cc \'b5\'c7\'c1\'f6\'be\'ca\'b4\'c2\'b4\'d9(\f0 MutiSet\f2\'c0\'ba \'c1\'df\'ba\'b9\'b0\'a1\'b4\'c9)\par
\tab - \f0 Set\f2\'c0\'ba \'c0\'da\'b5\'bf\'c0\'b8\'b7\'ce \'c1\'a4\'b7\'c4\'c0\'cc\'b5\'c7\'b8\'e7 (\'b1\'e2\'ba\'bb\'c0\'b8\'b7\'ce \f0 less \f2\'bf\'c0\'b8\'a7\'c2\'f7\'bc\'f8\'c0\'b8\'b7\'ce \'c1\'a4\'b7\'c4\'b5\'c7\'b0\'d4 \'b5\'c7\'be\'ee\'c0\'d6\'b4\'d9.)\par
\par
\tab * \'bb\'e7\'bf\'eb\'c7\'cf\'b4\'c2 \'b0\'e6\'bf\'ec\par
\tab\tab - \'c0\'fa\'c0\'e5\'b5\'c8 \'b5\'a5\'c0\'cc\'c5\'cd\'b5\'e9\'c0\'bb \'c1\'a4\'b7\'c4\'c7\'d8\'be\'df \'c7\'d2 \'b0\'e6\'bf\'ec\par
\tab\tab - \'b8\'b9\'c0\'ba \'c0\'da\'b7\'e1\'b5\'e9\'c0\'bb \'c0\'fa\'c0\'e5\'c7\'cf\'b0\'ed, \'c6\'af\'c1\'a4 \'c0\'da\'b7\'e1\'bf\'a1 \'b4\'eb\'c7\'d1 \'b0\'cb\'bb\'f6\'c0\'bb \'ba\'fc\'b8\'a3\'b0\'d4 \'c7\'d8\'be\'df \'c7\'d2 \'b0\'e6\'bf\'ec\par
\tab\tab\par
\tab\'bf\'b9)\par
\cf1\highlight2\f3\fs22\tab\f4 int\cf3  main()\par
\f3\tab\f4\{\par
\tab\f3\tab\f4 std::\cf4 set\cf3 &lt;\cf1 int\cf3 &gt; s;\par
\tab\f3\tab\f4 s.insert(1);\par
\tab\f3\tab\f4 s.insert(2);\par
\tab\f3\tab\f4 s.insert(3);\par
\tab\par
\tab\f3\tab\f4 std::\cf4 set\cf3 &lt;\cf1 int\cf3 &gt;::\cf4 iterator\cf3  it;\par
\tab\f3\tab\f4 it = s.find(2);\par
\tab\f3\tab\cf5\f4 //it = s.find(4);\cf3\par
\tab\f3\tab\cf1\f4 if\cf3  (it != s.end())\par
\tab\f3\tab\f4\tab std::cout &lt;&lt; \cf6 "\f5\'c3\'a3\'b4\'c2\'b0\'aa\f4  : "\cf3  &lt;&lt; *it &lt;&lt; std::endl;\par
\tab\f3\tab\cf1\f4 else\cf3\par
\tab\tab\f3\tab\f4 std::cout &lt;&lt; \cf6 "Error!"\cf3  &lt;&lt; std::endl;\par
\tab\f3\tab\cf1\f4 return\cf3  0;\par
\f3\tab\}\par
\cf7\highlight8\f6\fs19\par
\par
\cf0\highlight0\f0\fs20\par
}
&#x0;</Text>
  <Encrypted>false</Encrypted>
  <Name>Set</Name>
  <CreatedBy>Anonymous</CreatedBy>
  <CreatedOn>2017-03-28T10:18:59.1139953+09:00</CreatedOn>
  <UpdatedBy>Anonymous</UpdatedBy>
  <UpdatedOn>2017-03-28T12:05:45.4151534+09:00</UpdatedOn>
  <Words>Set
	- 연관 컨테이너 이며 '노드 기반 컨테이너' 이다.
	- 참고로 모든 연관컨테이너는 균형 2진 트리로 구현(레드-블랙트리)
	- 연관 컨테이너중 단순한 컨테이너로 Key라 불리는 원소(Value)의 집합으로 이루어진 컨테이너이다.
	- Map과의 차이점은 Set은 오직 Key만 저장하고 정렬한다는 점
	- Key값이 중복이 되지않는다(MutiSet은 중복가능)
	- Set은 자동으로 정렬이되며 (기본으로 less 오름차순으로 정렬되게 되어있다.)

	* 사용하는 경우
		- 저장된 데이터들을 정렬해야 할 경우
		- 많은 자료들을 저장하고, 특정 자료에 대한 검색을 빠르게 해야 할 경우
		
	예)
	int main()
	{
		std::set&lt;int&gt; s;
		s.insert(1);
		s.insert(2);
		s.insert(3);
	
		std::set&lt;int&gt;::iterator it;
		it = s.find(2);
		//it = s.find(4);
		if (it != s.end())
			std::cout &lt;&lt; "찾는값 : " &lt;&lt; *it &lt;&lt; std::endl;
		else
			std::cout &lt;&lt; "Error!" &lt;&lt; std::endl;
		return 0;
	}


</Words>
  <PublishedOn>0001-01-01T00:00:00</PublishedOn>
  <PublishedUrl />
  <PublishedService>0</PublishedService>
</Page>